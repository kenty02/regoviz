/**
 * Generated by orval v6.23.0 üç∫
 * Do not edit manually.
 * regoviz
 * api for regoviz
 * OpenAPI spec version: 1.0.0
 */
import {
	useMutation,
	useQuery,
	useSuspenseInfiniteQuery,
	useSuspenseQuery,
} from "@tanstack/react-query";
import type {
	InfiniteData,
	MutationFunction,
	QueryFunction,
	QueryKey,
	UseMutationOptions,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseInfiniteQueryOptions,
	UseSuspenseInfiniteQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import * as axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";
import type { GetAst200 } from "../model/getAst200";
import type { GetAstParams } from "../model/getAstParams";
import type { GetAstPretty200 } from "../model/getAstPretty200";
import type { GetAstPrettyParams } from "../model/getAstPrettyParams";
import type { GetCallTree200 } from "../model/getCallTree200";
import type { GetCallTreeAvailableEntrypoints200 } from "../model/getCallTreeAvailableEntrypoints200";
import type { GetCallTreeAvailableEntrypointsParams } from "../model/getCallTreeAvailableEntrypointsParams";
import type { GetCallTreeParams } from "../model/getCallTreeParams";
import type { GetDepTreeText200 } from "../model/getDepTreeText200";
import type { GetDepTreeTextParams } from "../model/getDepTreeTextParams";
import type { GetFlowchart200 } from "../model/getFlowchart200";
import type { GetFlowchartParams } from "../model/getFlowchartParams";
import type { GetIr200 } from "../model/getIr200";
import type { GetIrParams } from "../model/getIrParams";
import type { PostVarTrace200 } from "../model/postVarTrace200";
import type { PostVarTraceParams } from "../model/postVarTraceParams";
import type { Sample } from "../model/sample";

export const getSamples = (
	options?: AxiosRequestConfig,
): Promise<AxiosResponse<Sample[]>> => {
	return axios.default.get("/samples", options);
};

export const getGetSamplesQueryKey = () => {
	return ["/samples"] as const;
};

export const getGetSamplesQueryOptions = <
	TData = Awaited<ReturnType<typeof getSamples>>,
	TError = AxiosError<unknown>,
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof getSamples>>, TError, TData>
	>;
	axios?: AxiosRequestConfig;
}) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetSamplesQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getSamples>>> = ({
		signal,
	}) => getSamples({ signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSamples>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSamplesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSamples>>
>;
export type GetSamplesQueryError = AxiosError<unknown>;

export const useGetSamples = <
	TData = Awaited<ReturnType<typeof getSamples>>,
	TError = AxiosError<unknown>,
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof getSamples>>, TError, TData>
	>;
	axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSamplesQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetSamplesSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getSamples>>,
	TError = AxiosError<unknown>,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof getSamples>>,
			TError,
			TData
		>
	>;
	axios?: AxiosRequestConfig;
}) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetSamplesQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getSamples>>> = ({
		signal,
	}) => getSamples({ signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getSamples>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSamplesSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSamples>>
>;
export type GetSamplesSuspenseQueryError = AxiosError<unknown>;

export const useGetSamplesSuspense = <
	TData = Awaited<ReturnType<typeof getSamples>>,
	TError = AxiosError<unknown>,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof getSamples>>,
			TError,
			TData
		>
	>;
	axios?: AxiosRequestConfig;
}): UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSamplesSuspenseQueryOptions(options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetSamplesSuspenseInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getSamples>>>,
	TError = AxiosError<unknown>,
>(options?: {
	query?: Partial<
		UseSuspenseInfiniteQueryOptions<
			Awaited<ReturnType<typeof getSamples>>,
			TError,
			TData
		>
	>;
	axios?: AxiosRequestConfig;
}) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetSamplesQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getSamples>>> = ({
		signal,
	}) => getSamples({ signal, ...axiosOptions });

	return {
		queryKey,
		queryFn,
		...queryOptions,
	} as UseSuspenseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getSamples>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSamplesSuspenseInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSamples>>
>;
export type GetSamplesSuspenseInfiniteQueryError = AxiosError<unknown>;

export const useGetSamplesSuspenseInfinite = <
	TData = InfiniteData<Awaited<ReturnType<typeof getSamples>>>,
	TError = AxiosError<unknown>,
>(options?: {
	query?: Partial<
		UseSuspenseInfiniteQueryOptions<
			Awaited<ReturnType<typeof getSamples>>,
			TError,
			TData
		>
	>;
	axios?: AxiosRequestConfig;
}): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSamplesSuspenseInfiniteQueryOptions(options);

	const query = useSuspenseInfiniteQuery(
		queryOptions,
	) as UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getDepTreeText = (
	params: GetDepTreeTextParams,
	options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetDepTreeText200>> => {
	return axios.default.get("/depTreeText", {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetDepTreeTextQueryKey = (params: GetDepTreeTextParams) => {
	return ["/depTreeText", ...(params ? [params] : [])] as const;
};

export const getGetDepTreeTextQueryOptions = <
	TData = Awaited<ReturnType<typeof getDepTreeText>>,
	TError = AxiosError<unknown>,
>(
	params: GetDepTreeTextParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getDepTreeText>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetDepTreeTextQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepTreeText>>> = ({
		signal,
	}) => getDepTreeText(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getDepTreeText>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetDepTreeTextQueryResult = NonNullable<
	Awaited<ReturnType<typeof getDepTreeText>>
>;
export type GetDepTreeTextQueryError = AxiosError<unknown>;

export const useGetDepTreeText = <
	TData = Awaited<ReturnType<typeof getDepTreeText>>,
	TError = AxiosError<unknown>,
>(
	params: GetDepTreeTextParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getDepTreeText>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetDepTreeTextQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetDepTreeTextSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getDepTreeText>>,
	TError = AxiosError<unknown>,
>(
	params: GetDepTreeTextParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getDepTreeText>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetDepTreeTextQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepTreeText>>> = ({
		signal,
	}) => getDepTreeText(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getDepTreeText>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetDepTreeTextSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getDepTreeText>>
>;
export type GetDepTreeTextSuspenseQueryError = AxiosError<unknown>;

export const useGetDepTreeTextSuspense = <
	TData = Awaited<ReturnType<typeof getDepTreeText>>,
	TError = AxiosError<unknown>,
>(
	params: GetDepTreeTextParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getDepTreeText>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
): UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetDepTreeTextSuspenseQueryOptions(params, options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetDepTreeTextSuspenseInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getDepTreeText>>>,
	TError = AxiosError<unknown>,
>(
	params: GetDepTreeTextParams,
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getDepTreeText>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetDepTreeTextQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepTreeText>>> = ({
		signal,
	}) => getDepTreeText(params, { signal, ...axiosOptions });

	return {
		queryKey,
		queryFn,
		...queryOptions,
	} as UseSuspenseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getDepTreeText>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetDepTreeTextSuspenseInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getDepTreeText>>
>;
export type GetDepTreeTextSuspenseInfiniteQueryError = AxiosError<unknown>;

export const useGetDepTreeTextSuspenseInfinite = <
	TData = InfiniteData<Awaited<ReturnType<typeof getDepTreeText>>>,
	TError = AxiosError<unknown>,
>(
	params: GetDepTreeTextParams,
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getDepTreeText>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetDepTreeTextSuspenseInfiniteQueryOptions(
		params,
		options,
	);

	const query = useSuspenseInfiniteQuery(
		queryOptions,
	) as UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getFlowchart = (
	params: GetFlowchartParams,
	options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetFlowchart200>> => {
	return axios.default.get("/flowchart", {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetFlowchartQueryKey = (params: GetFlowchartParams) => {
	return ["/flowchart", ...(params ? [params] : [])] as const;
};

export const getGetFlowchartQueryOptions = <
	TData = Awaited<ReturnType<typeof getFlowchart>>,
	TError = AxiosError<unknown>,
>(
	params: GetFlowchartParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getFlowchart>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetFlowchartQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getFlowchart>>> = ({
		signal,
	}) => getFlowchart(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getFlowchart>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetFlowchartQueryResult = NonNullable<
	Awaited<ReturnType<typeof getFlowchart>>
>;
export type GetFlowchartQueryError = AxiosError<unknown>;

export const useGetFlowchart = <
	TData = Awaited<ReturnType<typeof getFlowchart>>,
	TError = AxiosError<unknown>,
>(
	params: GetFlowchartParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getFlowchart>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetFlowchartQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetFlowchartSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getFlowchart>>,
	TError = AxiosError<unknown>,
>(
	params: GetFlowchartParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getFlowchart>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetFlowchartQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getFlowchart>>> = ({
		signal,
	}) => getFlowchart(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getFlowchart>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetFlowchartSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getFlowchart>>
>;
export type GetFlowchartSuspenseQueryError = AxiosError<unknown>;

export const useGetFlowchartSuspense = <
	TData = Awaited<ReturnType<typeof getFlowchart>>,
	TError = AxiosError<unknown>,
>(
	params: GetFlowchartParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getFlowchart>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
): UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetFlowchartSuspenseQueryOptions(params, options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetFlowchartSuspenseInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getFlowchart>>>,
	TError = AxiosError<unknown>,
>(
	params: GetFlowchartParams,
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getFlowchart>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetFlowchartQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getFlowchart>>> = ({
		signal,
	}) => getFlowchart(params, { signal, ...axiosOptions });

	return {
		queryKey,
		queryFn,
		...queryOptions,
	} as UseSuspenseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getFlowchart>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetFlowchartSuspenseInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getFlowchart>>
>;
export type GetFlowchartSuspenseInfiniteQueryError = AxiosError<unknown>;

export const useGetFlowchartSuspenseInfinite = <
	TData = InfiniteData<Awaited<ReturnType<typeof getFlowchart>>>,
	TError = AxiosError<unknown>,
>(
	params: GetFlowchartParams,
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getFlowchart>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetFlowchartSuspenseInfiniteQueryOptions(
		params,
		options,
	);

	const query = useSuspenseInfiniteQuery(
		queryOptions,
	) as UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const postVarTrace = (
	params: PostVarTraceParams,
	options?: AxiosRequestConfig,
): Promise<AxiosResponse<PostVarTrace200>> => {
	return axios.default.post("/varTrace", undefined, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getPostVarTraceMutationOptions = <
	TError = AxiosError<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof postVarTrace>>,
		TError,
		{ params: PostVarTraceParams },
		TContext
	>;
	axios?: AxiosRequestConfig;
}): UseMutationOptions<
	Awaited<ReturnType<typeof postVarTrace>>,
	TError,
	{ params: PostVarTraceParams },
	TContext
> => {
	const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof postVarTrace>>,
		{ params: PostVarTraceParams }
	> = (props) => {
		const { params } = props ?? {};

		return postVarTrace(params, axiosOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type PostVarTraceMutationResult = NonNullable<
	Awaited<ReturnType<typeof postVarTrace>>
>;

export type PostVarTraceMutationError = AxiosError<unknown>;

export const usePostVarTrace = <
	TError = AxiosError<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof postVarTrace>>,
		TError,
		{ params: PostVarTraceParams },
		TContext
	>;
	axios?: AxiosRequestConfig;
}) => {
	const mutationOptions = getPostVarTraceMutationOptions(options);

	return useMutation(mutationOptions);
};
export const getAst = (
	params: GetAstParams,
	options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetAst200>> => {
	return axios.default.get("/ast", {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetAstQueryKey = (params: GetAstParams) => {
	return ["/ast", ...(params ? [params] : [])] as const;
};

export const getGetAstQueryOptions = <
	TData = Awaited<ReturnType<typeof getAst>>,
	TError = AxiosError<unknown>,
>(
	params: GetAstParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAst>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetAstQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAst>>> = ({
		signal,
	}) => getAst(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getAst>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetAstQueryResult = NonNullable<Awaited<ReturnType<typeof getAst>>>;
export type GetAstQueryError = AxiosError<unknown>;

export const useGetAst = <
	TData = Awaited<ReturnType<typeof getAst>>,
	TError = AxiosError<unknown>,
>(
	params: GetAstParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAst>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetAstQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetAstSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getAst>>,
	TError = AxiosError<unknown>,
>(
	params: GetAstParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAst>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetAstQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAst>>> = ({
		signal,
	}) => getAst(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getAst>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetAstSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getAst>>
>;
export type GetAstSuspenseQueryError = AxiosError<unknown>;

export const useGetAstSuspense = <
	TData = Awaited<ReturnType<typeof getAst>>,
	TError = AxiosError<unknown>,
>(
	params: GetAstParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAst>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
): UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetAstSuspenseQueryOptions(params, options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetAstSuspenseInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getAst>>>,
	TError = AxiosError<unknown>,
>(
	params: GetAstParams,
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getAst>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetAstQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAst>>> = ({
		signal,
	}) => getAst(params, { signal, ...axiosOptions });

	return {
		queryKey,
		queryFn,
		...queryOptions,
	} as UseSuspenseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getAst>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetAstSuspenseInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getAst>>
>;
export type GetAstSuspenseInfiniteQueryError = AxiosError<unknown>;

export const useGetAstSuspenseInfinite = <
	TData = InfiniteData<Awaited<ReturnType<typeof getAst>>>,
	TError = AxiosError<unknown>,
>(
	params: GetAstParams,
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getAst>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetAstSuspenseInfiniteQueryOptions(params, options);

	const query = useSuspenseInfiniteQuery(
		queryOptions,
	) as UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getAstPretty = (
	params: GetAstPrettyParams,
	options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetAstPretty200>> => {
	return axios.default.get("/astPretty", {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetAstPrettyQueryKey = (params: GetAstPrettyParams) => {
	return ["/astPretty", ...(params ? [params] : [])] as const;
};

export const getGetAstPrettyQueryOptions = <
	TData = Awaited<ReturnType<typeof getAstPretty>>,
	TError = AxiosError<unknown>,
>(
	params: GetAstPrettyParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAstPretty>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetAstPrettyQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAstPretty>>> = ({
		signal,
	}) => getAstPretty(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getAstPretty>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetAstPrettyQueryResult = NonNullable<
	Awaited<ReturnType<typeof getAstPretty>>
>;
export type GetAstPrettyQueryError = AxiosError<unknown>;

export const useGetAstPretty = <
	TData = Awaited<ReturnType<typeof getAstPretty>>,
	TError = AxiosError<unknown>,
>(
	params: GetAstPrettyParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAstPretty>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetAstPrettyQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetAstPrettySuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getAstPretty>>,
	TError = AxiosError<unknown>,
>(
	params: GetAstPrettyParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getAstPretty>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetAstPrettyQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAstPretty>>> = ({
		signal,
	}) => getAstPretty(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getAstPretty>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetAstPrettySuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getAstPretty>>
>;
export type GetAstPrettySuspenseQueryError = AxiosError<unknown>;

export const useGetAstPrettySuspense = <
	TData = Awaited<ReturnType<typeof getAstPretty>>,
	TError = AxiosError<unknown>,
>(
	params: GetAstPrettyParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getAstPretty>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
): UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetAstPrettySuspenseQueryOptions(params, options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetAstPrettySuspenseInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getAstPretty>>>,
	TError = AxiosError<unknown>,
>(
	params: GetAstPrettyParams,
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getAstPretty>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetAstPrettyQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAstPretty>>> = ({
		signal,
	}) => getAstPretty(params, { signal, ...axiosOptions });

	return {
		queryKey,
		queryFn,
		...queryOptions,
	} as UseSuspenseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getAstPretty>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetAstPrettySuspenseInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getAstPretty>>
>;
export type GetAstPrettySuspenseInfiniteQueryError = AxiosError<unknown>;

export const useGetAstPrettySuspenseInfinite = <
	TData = InfiniteData<Awaited<ReturnType<typeof getAstPretty>>>,
	TError = AxiosError<unknown>,
>(
	params: GetAstPrettyParams,
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getAstPretty>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetAstPrettySuspenseInfiniteQueryOptions(
		params,
		options,
	);

	const query = useSuspenseInfiniteQuery(
		queryOptions,
	) as UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getIr = (
	params: GetIrParams,
	options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetIr200>> => {
	return axios.default.get("/ir", {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetIrQueryKey = (params: GetIrParams) => {
	return ["/ir", ...(params ? [params] : [])] as const;
};

export const getGetIrQueryOptions = <
	TData = Awaited<ReturnType<typeof getIr>>,
	TError = AxiosError<unknown>,
>(
	params: GetIrParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getIr>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetIrQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getIr>>> = ({
		signal,
	}) => getIr(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getIr>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetIrQueryResult = NonNullable<Awaited<ReturnType<typeof getIr>>>;
export type GetIrQueryError = AxiosError<unknown>;

export const useGetIr = <
	TData = Awaited<ReturnType<typeof getIr>>,
	TError = AxiosError<unknown>,
>(
	params: GetIrParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getIr>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetIrQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetIrSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getIr>>,
	TError = AxiosError<unknown>,
>(
	params: GetIrParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<Awaited<ReturnType<typeof getIr>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetIrQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getIr>>> = ({
		signal,
	}) => getIr(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getIr>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetIrSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getIr>>
>;
export type GetIrSuspenseQueryError = AxiosError<unknown>;

export const useGetIrSuspense = <
	TData = Awaited<ReturnType<typeof getIr>>,
	TError = AxiosError<unknown>,
>(
	params: GetIrParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<Awaited<ReturnType<typeof getIr>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
): UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetIrSuspenseQueryOptions(params, options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetIrSuspenseInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getIr>>>,
	TError = AxiosError<unknown>,
>(
	params: GetIrParams,
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getIr>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetIrQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getIr>>> = ({
		signal,
	}) => getIr(params, { signal, ...axiosOptions });

	return {
		queryKey,
		queryFn,
		...queryOptions,
	} as UseSuspenseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getIr>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetIrSuspenseInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getIr>>
>;
export type GetIrSuspenseInfiniteQueryError = AxiosError<unknown>;

export const useGetIrSuspenseInfinite = <
	TData = InfiniteData<Awaited<ReturnType<typeof getIr>>>,
	TError = AxiosError<unknown>,
>(
	params: GetIrParams,
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getIr>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetIrSuspenseInfiniteQueryOptions(params, options);

	const query = useSuspenseInfiniteQuery(
		queryOptions,
	) as UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getCallTree = (
	params: GetCallTreeParams,
	options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetCallTree200>> => {
	return axios.default.get("/callTree", {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetCallTreeQueryKey = (params: GetCallTreeParams) => {
	return ["/callTree", ...(params ? [params] : [])] as const;
};

export const getGetCallTreeQueryOptions = <
	TData = Awaited<ReturnType<typeof getCallTree>>,
	TError = AxiosError<unknown>,
>(
	params: GetCallTreeParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getCallTree>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetCallTreeQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCallTree>>> = ({
		signal,
	}) => getCallTree(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getCallTree>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetCallTreeQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCallTree>>
>;
export type GetCallTreeQueryError = AxiosError<unknown>;

export const useGetCallTree = <
	TData = Awaited<ReturnType<typeof getCallTree>>,
	TError = AxiosError<unknown>,
>(
	params: GetCallTreeParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getCallTree>>, TError, TData>
		>;
		axios?: AxiosRequestConfig;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetCallTreeQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetCallTreeSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getCallTree>>,
	TError = AxiosError<unknown>,
>(
	params: GetCallTreeParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getCallTree>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetCallTreeQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCallTree>>> = ({
		signal,
	}) => getCallTree(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getCallTree>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetCallTreeSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCallTree>>
>;
export type GetCallTreeSuspenseQueryError = AxiosError<unknown>;

export const useGetCallTreeSuspense = <
	TData = Awaited<ReturnType<typeof getCallTree>>,
	TError = AxiosError<unknown>,
>(
	params: GetCallTreeParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getCallTree>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
): UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetCallTreeSuspenseQueryOptions(params, options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetCallTreeSuspenseInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getCallTree>>>,
	TError = AxiosError<unknown>,
>(
	params: GetCallTreeParams,
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getCallTree>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetCallTreeQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCallTree>>> = ({
		signal,
	}) => getCallTree(params, { signal, ...axiosOptions });

	return {
		queryKey,
		queryFn,
		...queryOptions,
	} as UseSuspenseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getCallTree>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetCallTreeSuspenseInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCallTree>>
>;
export type GetCallTreeSuspenseInfiniteQueryError = AxiosError<unknown>;

export const useGetCallTreeSuspenseInfinite = <
	TData = InfiniteData<Awaited<ReturnType<typeof getCallTree>>>,
	TError = AxiosError<unknown>,
>(
	params: GetCallTreeParams,
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getCallTree>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetCallTreeSuspenseInfiniteQueryOptions(
		params,
		options,
	);

	const query = useSuspenseInfiniteQuery(
		queryOptions,
	) as UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getCallTreeAvailableEntrypoints = (
	params: GetCallTreeAvailableEntrypointsParams,
	options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetCallTreeAvailableEntrypoints200>> => {
	return axios.default.get("/callTree/availableEntrypoints", {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetCallTreeAvailableEntrypointsQueryKey = (
	params: GetCallTreeAvailableEntrypointsParams,
) => {
	return [
		"/callTree/availableEntrypoints",
		...(params ? [params] : []),
	] as const;
};

export const getGetCallTreeAvailableEntrypointsQueryOptions = <
	TData = Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>,
	TError = AxiosError<unknown>,
>(
	params: GetCallTreeAvailableEntrypointsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGetCallTreeAvailableEntrypointsQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>
	> = ({ signal }) =>
		getCallTreeAvailableEntrypoints(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetCallTreeAvailableEntrypointsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>
>;
export type GetCallTreeAvailableEntrypointsQueryError = AxiosError<unknown>;

export const useGetCallTreeAvailableEntrypoints = <
	TData = Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>,
	TError = AxiosError<unknown>,
>(
	params: GetCallTreeAvailableEntrypointsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetCallTreeAvailableEntrypointsQueryOptions(
		params,
		options,
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetCallTreeAvailableEntrypointsSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>,
	TError = AxiosError<unknown>,
>(
	params: GetCallTreeAvailableEntrypointsParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGetCallTreeAvailableEntrypointsQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>
	> = ({ signal }) =>
		getCallTreeAvailableEntrypoints(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetCallTreeAvailableEntrypointsSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>
>;
export type GetCallTreeAvailableEntrypointsSuspenseQueryError =
	AxiosError<unknown>;

export const useGetCallTreeAvailableEntrypointsSuspense = <
	TData = Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>,
	TError = AxiosError<unknown>,
>(
	params: GetCallTreeAvailableEntrypointsParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
): UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetCallTreeAvailableEntrypointsSuspenseQueryOptions(
		params,
		options,
	);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetCallTreeAvailableEntrypointsSuspenseInfiniteQueryOptions = <
	TData = InfiniteData<
		Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>
	>,
	TError = AxiosError<unknown>,
>(
	params: GetCallTreeAvailableEntrypointsParams,
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGetCallTreeAvailableEntrypointsQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>
	> = ({ signal }) =>
		getCallTreeAvailableEntrypoints(params, { signal, ...axiosOptions });

	return {
		queryKey,
		queryFn,
		...queryOptions,
	} as UseSuspenseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetCallTreeAvailableEntrypointsSuspenseInfiniteQueryResult =
	NonNullable<Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>>;
export type GetCallTreeAvailableEntrypointsSuspenseInfiniteQueryError =
	AxiosError<unknown>;

export const useGetCallTreeAvailableEntrypointsSuspenseInfinite = <
	TData = InfiniteData<
		Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>
	>,
	TError = AxiosError<unknown>,
>(
	params: GetCallTreeAvailableEntrypointsParams,
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getCallTreeAvailableEntrypoints>>,
				TError,
				TData
			>
		>;
		axios?: AxiosRequestConfig;
	},
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions =
		getGetCallTreeAvailableEntrypointsSuspenseInfiniteQueryOptions(
			params,
			options,
		);

	const query = useSuspenseInfiniteQuery(
		queryOptions,
	) as UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
};
